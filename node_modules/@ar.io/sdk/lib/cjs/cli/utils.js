"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getANTStateFromOptions = exports.requiredPositiveIntegerFromOptions = exports.positiveIntegerFromOptions = exports.requiredStringArrayFromOptions = exports.requiredStringFromOptions = exports.writeANTFromOptions = exports.readANTFromOptions = exports.requiredProcessIdFromOptions = exports.assertConfirmationPrompt = exports.confirmationPrompt = exports.assertEnoughBalance = exports.requiredMIOFromOptions = exports.recordTypeFromOptions = exports.redelegateParamsFromOptions = exports.requiredTargetAndQuantityFromOptions = exports.gatewaySettingsFromOptions = exports.writeActionTagsFromOptions = exports.requiredInitiatorFromOptions = exports.epochInputFromOptions = exports.paginationParamsFromOptions = exports.requiredAddressFromOptions = exports.addressFromOptions = exports.formatARIOWithCommas = exports.writeARIOFromOptions = exports.requiredAoSignerFromOptions = exports.requiredContractSignerFromOptions = exports.readARIOFromOptions = exports.getLoggerFromOptions = exports.jwkToAddress = exports.requiredJwkFromOptions = exports.arioProcessIdFromOptions = exports.makeCommand = exports.applyOptions = exports.runCommand = exports.stringifyJsonForCLIDisplay = void 0;
/**
 * Copyright (C) 2022-2024 Permanent Data Solutions, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const aoconnect_1 = require("@permaweb/aoconnect");
const commander_1 = require("commander");
const fs_1 = require("fs");
const prompts_1 = __importDefault(require("prompts"));
const index_js_1 = require("../node/index.js");
const options_js_1 = require("./options.js");
function stringifyJsonForCLIDisplay(json) {
    return JSON.stringify(json, null, 2);
}
exports.stringifyJsonForCLIDisplay = stringifyJsonForCLIDisplay;
function logCommandOutput(output) {
    console.log(stringifyJsonForCLIDisplay(output));
}
function exitWithErrorLog(error, debug = false) {
    let errorLog;
    if (error instanceof Error) {
        errorLog = error.message;
        if (debug && error.stack !== undefined) {
            errorLog = error.stack;
        }
    }
    else {
        errorLog = stringifyJsonForCLIDisplay(error);
    }
    console.error(errorLog);
    process.exit(1);
}
async function runCommand(command, action) {
    const options = command.optsWithGlobals();
    try {
        const output = await action(options);
        logCommandOutput(output);
        process.exit(0);
    }
    catch (error) {
        exitWithErrorLog(error, options.debug);
    }
}
exports.runCommand = runCommand;
function applyOptions(command, options) {
    [...options].forEach((option) => {
        command.option(option.alias, option.description, option.default);
    });
    return command;
}
exports.applyOptions = applyOptions;
function makeCommand({ description, name, options = [], action, }) {
    const command = commander_1.program.command(name).description(description);
    const appliedCommand = applyOptions(command, [...options, ...options_js_1.globalOptions]);
    if (action !== undefined) {
        appliedCommand.action(() => runCommand(appliedCommand, action));
    }
    return appliedCommand;
}
exports.makeCommand = makeCommand;
function arioProcessIdFromOptions({ arioProcessId, dev, }) {
    return arioProcessId !== undefined
        ? arioProcessId
        : dev
            ? index_js_1.ARIO_DEVNET_PROCESS_ID
            : index_js_1.ARIO_TESTNET_PROCESS_ID;
}
exports.arioProcessIdFromOptions = arioProcessIdFromOptions;
function jwkFromOptions({ privateKey, walletFile, }) {
    if (privateKey !== undefined) {
        return JSON.parse(privateKey);
    }
    if (walletFile !== undefined) {
        return JSON.parse((0, fs_1.readFileSync)(walletFile, 'utf-8'));
    }
    return undefined;
}
function requiredJwkFromOptions(options) {
    const jwk = jwkFromOptions(options);
    if (jwk === undefined) {
        throw new Error('No JWK provided for signing!\nPlease provide a stringified JWK with `--private-key` or the file path of a jwk.json file with `--wallet-file`');
    }
    return jwk;
}
exports.requiredJwkFromOptions = requiredJwkFromOptions;
function jwkToAddress(jwk) {
    return (0, index_js_1.sha256B64Url)((0, index_js_1.fromB64Url)(jwk.n));
}
exports.jwkToAddress = jwkToAddress;
function setLoggerIfDebug(options) {
    if (options.debug) {
        index_js_1.Logger.default.setLogLevel('debug');
    }
}
function getLoggerFromOptions(options) {
    setLoggerIfDebug(options);
    return index_js_1.Logger.default;
}
exports.getLoggerFromOptions = getLoggerFromOptions;
function aoProcessFromOptions(options) {
    return new index_js_1.AOProcess({
        processId: arioProcessIdFromOptions(options),
        ao: (0, aoconnect_1.connect)({
            CU_URL: options.cuUrl,
        }),
    });
}
function readARIOFromOptions(options) {
    setLoggerIfDebug(options);
    return index_js_1.ARIO.init({
        process: aoProcessFromOptions(options),
    });
}
exports.readARIOFromOptions = readARIOFromOptions;
function requiredContractSignerFromOptions(options) {
    // TODO: Support other wallet types
    const jwk = requiredJwkFromOptions(options);
    const signer = new index_js_1.ArweaveSigner(jwk);
    return { signer, signerAddress: jwkToAddress(jwk) };
}
exports.requiredContractSignerFromOptions = requiredContractSignerFromOptions;
function requiredAoSignerFromOptions(options) {
    return (0, index_js_1.createAoSigner)(requiredContractSignerFromOptions(options).signer);
}
exports.requiredAoSignerFromOptions = requiredAoSignerFromOptions;
function writeARIOFromOptions(options) {
    const { signer, signerAddress } = requiredContractSignerFromOptions(options);
    setLoggerIfDebug(options);
    return {
        ario: index_js_1.ARIO.init({
            process: aoProcessFromOptions(options),
            signer,
        }),
        signerAddress,
    };
}
exports.writeARIOFromOptions = writeARIOFromOptions;
function formatARIOWithCommas(value) {
    const [integerPart, decimalPart] = value.toString().split('.');
    const integerWithCommas = integerPart.replace(/\B(?=(\d{3})+(?!\d))/g, ',');
    if (decimalPart === undefined) {
        return integerWithCommas;
    }
    return integerWithCommas + '.' + decimalPart;
}
exports.formatARIOWithCommas = formatARIOWithCommas;
/** helper to get address from --address option first, then check wallet options  */
function addressFromOptions(options) {
    if (options.address !== undefined) {
        return options.address;
    }
    // TODO: Support other wallet types
    const jwk = jwkFromOptions(options);
    if (jwk !== undefined) {
        return jwkToAddress(jwk);
    }
    return undefined;
}
exports.addressFromOptions = addressFromOptions;
function requiredAddressFromOptions(options) {
    const address = addressFromOptions(options);
    if (address !== undefined) {
        return address;
    }
    throw new Error('No address provided. Use --address or --wallet-file');
}
exports.requiredAddressFromOptions = requiredAddressFromOptions;
const defaultCliPaginationLimit = 10; // more friendly UX than 100
function paginationParamsFromOptions(options) {
    const { cursor, limit, sortBy, sortOrder } = options;
    if (sortOrder !== undefined && !['asc', 'desc'].includes(sortOrder)) {
        throw new Error(`Invalid sort order: ${sortOrder}, must be "asc" or "desc"`);
    }
    const numberLimit = limit !== undefined ? +limit : defaultCliPaginationLimit;
    if (isNaN(numberLimit) || numberLimit <= 0) {
        throw new Error(`Invalid limit: ${numberLimit}, must be a positive number`);
    }
    return {
        cursor,
        limit: numberLimit,
        sortBy,
        sortOrder,
    };
}
exports.paginationParamsFromOptions = paginationParamsFromOptions;
function epochInputFromOptions(options) {
    if (options.epochIndex !== undefined) {
        return { epochIndex: +options.epochIndex };
    }
    if (options.timestamp !== undefined) {
        return { timestamp: +options.timestamp };
    }
    return undefined;
}
exports.epochInputFromOptions = epochInputFromOptions;
function requiredInitiatorFromOptions(options) {
    if (options.initiator !== undefined) {
        return options.initiator;
    }
    return requiredAddressFromOptions(options);
}
exports.requiredInitiatorFromOptions = requiredInitiatorFromOptions;
function writeActionTagsFromOptions(options) {
    if (options.tags === undefined) {
        return {};
    }
    if (!Array.isArray(options.tags)) {
        throw new Error('Tags must be an array');
    }
    if (options.tags.length === 0) {
        return {};
    }
    if (options.tags.length % 2 !== 0) {
        throw new Error('Tags must be an array of key-value pairs');
    }
    const tags = [];
    for (let i = 0; i < options.tags.length; i += 2) {
        tags.push({
            name: options.tags[i],
            value: options.tags[i + 1],
        });
    }
    return {
        tags,
    };
}
exports.writeActionTagsFromOptions = writeActionTagsFromOptions;
function gatewaySettingsFromOptions({ allowDelegatedStaking, autoStake, delegateRewardShareRatio, fqdn, label, minDelegatedStake, note, observerAddress, port, properties, allowedDelegates, }) {
    return {
        observerAddress,
        allowDelegatedStaking,
        autoStake,
        delegateRewardShareRatio: delegateRewardShareRatio !== undefined
            ? +delegateRewardShareRatio
            : undefined,
        allowedDelegates,
        fqdn,
        label,
        minDelegatedStake: minDelegatedStake !== undefined ? +minDelegatedStake : undefined,
        note,
        port: port !== undefined ? +port : undefined,
        properties,
    };
}
exports.gatewaySettingsFromOptions = gatewaySettingsFromOptions;
function requiredTargetAndQuantityFromOptions(options) {
    if (options.target === undefined) {
        throw new Error('No target provided. Use --target');
    }
    if (options.quantity === undefined) {
        throw new Error('No quantity provided. Use --quantity');
    }
    return {
        target: options.target,
        arioQuantity: new index_js_1.ARIOToken(+options.quantity),
    };
}
exports.requiredTargetAndQuantityFromOptions = requiredTargetAndQuantityFromOptions;
function redelegateParamsFromOptions(options) {
    const { target, arioQuantity: aRIOQuantity } = requiredTargetAndQuantityFromOptions(options);
    const source = options.source;
    if (source === undefined) {
        throw new Error('No source provided. Use --source');
    }
    return {
        target,
        source,
        vaultId: options.vaultId,
        stakeQty: aRIOQuantity.toMARIO(),
    };
}
exports.redelegateParamsFromOptions = redelegateParamsFromOptions;
function recordTypeFromOptions(options) {
    options.type ??= 'lease';
    if (options.type !== 'lease' && options.type !== 'permabuy') {
        throw new Error(`Invalid type. Valid types are: lease, permabuy`);
    }
    return options.type;
}
exports.recordTypeFromOptions = recordTypeFromOptions;
function requiredMIOFromOptions(options, key) {
    if (options[key] === undefined) {
        throw new Error(`No ${key} provided. Use --${key} denominated in ARIO`);
    }
    return new index_js_1.ARIOToken(+options[key]).toMARIO();
}
exports.requiredMIOFromOptions = requiredMIOFromOptions;
async function assertEnoughBalance(ario, address, arioQuantity) {
    const balance = await ario.getBalance({ address });
    if (balance < arioQuantity.toMARIO().valueOf()) {
        throw new Error(`Insufficient ARIO balance for action. Balance available: ${new index_js_1.mARIOToken(balance).toARIO()} ARIO`);
    }
}
exports.assertEnoughBalance = assertEnoughBalance;
async function confirmationPrompt(message) {
    const { confirm } = await (0, prompts_1.default)({
        type: 'confirm',
        name: 'confirm',
        message,
    });
    return confirm;
}
exports.confirmationPrompt = confirmationPrompt;
async function assertConfirmationPrompt(message, options) {
    if (options.skipConfirmation) {
        return true;
    }
    return confirmationPrompt(message);
}
exports.assertConfirmationPrompt = assertConfirmationPrompt;
function requiredProcessIdFromOptions(o) {
    if (o.processId === undefined) {
        throw new Error('--process-id is required');
    }
    return o.processId;
}
exports.requiredProcessIdFromOptions = requiredProcessIdFromOptions;
function ANTProcessFromOptions(options) {
    return new index_js_1.AOProcess({
        processId: requiredProcessIdFromOptions(options),
        ao: (0, aoconnect_1.connect)({
            CU_URL: options.cuUrl,
        }),
    });
}
function readANTFromOptions(options) {
    return index_js_1.ANT.init({
        process: ANTProcessFromOptions(options),
    });
}
exports.readANTFromOptions = readANTFromOptions;
function writeANTFromOptions(options, signer) {
    signer ??= requiredContractSignerFromOptions(options).signer;
    return index_js_1.ANT.init({
        process: ANTProcessFromOptions(options),
        signer,
    });
}
exports.writeANTFromOptions = writeANTFromOptions;
function requiredStringFromOptions(options, key) {
    const value = options[key];
    if (value === undefined) {
        throw new Error(`--${key} is required`);
    }
    return value;
}
exports.requiredStringFromOptions = requiredStringFromOptions;
function requiredStringArrayFromOptions(options, key) {
    const value = options[key];
    if (value === undefined) {
        throw new Error(`--${key} is required`);
    }
    if (!Array.isArray(value)) {
        throw new Error(`--${key} must be an array`);
    }
    return value;
}
exports.requiredStringArrayFromOptions = requiredStringArrayFromOptions;
function positiveIntegerFromOptions(options, key) {
    const value = options[key];
    if (value === undefined) {
        return undefined;
    }
    const numberValue = +value;
    if (isNaN(numberValue) || numberValue <= 0) {
        throw new Error(`Invalid ${key}: ${value}, must be a positive number`);
    }
    return numberValue;
}
exports.positiveIntegerFromOptions = positiveIntegerFromOptions;
function requiredPositiveIntegerFromOptions(options, key) {
    const value = positiveIntegerFromOptions(options, key);
    if (value === undefined) {
        throw new Error(`--${key} is required`);
    }
    return value;
}
exports.requiredPositiveIntegerFromOptions = requiredPositiveIntegerFromOptions;
function getANTStateFromOptions(options) {
    return (0, index_js_1.initANTStateForAddress)({
        owner: requiredAddressFromOptions(options),
        targetId: options.target,
        controllers: options.controllers,
        description: options.description,
        ticker: options.ticker,
        name: options.name,
        keywords: options.keywords,
        ttlSeconds: options.ttlSeconds !== undefined ? +options.ttlSeconds : 3600,
    });
}
exports.getANTStateFromOptions = getANTStateFromOptions;
