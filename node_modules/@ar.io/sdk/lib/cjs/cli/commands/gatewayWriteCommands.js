"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.redelegateStake = exports.decreaseDelegateStake = exports.delegateStake = exports.cancelWithdrawal = exports.instantWithdrawal = exports.decreaseOperatorStake = exports.increaseOperatorStake = exports.saveObservations = exports.leaveNetwork = exports.updateGatewaySettings = exports.joinNetwork = void 0;
/**
 * Copyright (C) 2022-2024 Permanent Data Solutions, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const prompts_1 = __importDefault(require("prompts"));
const index_js_1 = require("../../node/index.js");
const utils_js_1 = require("../utils.js");
async function joinNetwork(options) {
    const { ario, signerAddress } = (0, utils_js_1.writeARIOFromOptions)(options);
    const mARIOQuantity = (0, utils_js_1.requiredMIOFromOptions)(options, 'operatorStake');
    const settings = {
        ...(0, utils_js_1.gatewaySettingsFromOptions)(options),
        operatorStake: mARIOQuantity.valueOf(),
    };
    if (settings.label === undefined) {
        throw new Error('Label is required. Please provide a --label for your node.');
    }
    if (settings.fqdn === undefined) {
        throw new Error('FQDN is required. Please provide a --fqdn for your node.');
    }
    if (!options.skipConfirmation) {
        const settings = await ario.getGatewayRegistrySettings();
        if (settings.operators.minStake > mARIOQuantity.valueOf()) {
            throw new Error(`The minimum operator stake is ${(0, utils_js_1.formatARIOWithCommas)(new index_js_1.mARIOToken(settings.operators.minStake).toARIO())} ARIO. Please provide a higher stake.`);
        }
        await (0, utils_js_1.assertEnoughBalance)(ario, signerAddress, mARIOQuantity.toARIO());
        await (0, utils_js_1.assertConfirmationPrompt)(`Gateway Settings:\n\n${JSON.stringify(settings, null, 2)}\n\nYou are about to stake ${(0, utils_js_1.formatARIOWithCommas)(mARIOQuantity.toARIO())} ARIO to join the AR.IO network\nAre you sure?\n`, options);
    }
    const result = await ario.joinNetwork(settings, (0, utils_js_1.writeActionTagsFromOptions)(options));
    const output = {
        joinNetworkResult: result,
        joinedAddress: signerAddress,
        message: `Congratulations! You have successfully joined the AR.IO network  (;`,
    };
    return output;
}
exports.joinNetwork = joinNetwork;
async function updateGatewaySettings(options) {
    const { ario, signerAddress } = (0, utils_js_1.writeARIOFromOptions)(options);
    const gatewaySettings = (0, utils_js_1.gatewaySettingsFromOptions)(options);
    if (Object.keys(gatewaySettings).length === 0) {
        // TODO: The contract accepts empty Update-Gateway-Settings actions, but we'll throw in the CLI for now
        throw new Error('No gateway settings provided');
    }
    await (0, utils_js_1.assertConfirmationPrompt)(`Gateway Settings:\n\n${(0, utils_js_1.stringifyJsonForCLIDisplay)(gatewaySettings)}\n\nYou are about to update your gateway settings to the above\nAre you sure?\n`, options);
    const result = await ario.updateGatewaySettings(gatewaySettings, (0, utils_js_1.writeActionTagsFromOptions)(options));
    const output = {
        updateGatewaySettingsResult: result,
        updatedGatewayAddress: signerAddress,
        message: `Gateway settings updated successfully`,
    };
    return output;
}
exports.updateGatewaySettings = updateGatewaySettings;
async function leaveNetwork(options) {
    const { ario, signerAddress } = (0, utils_js_1.writeARIOFromOptions)(options);
    if (!options.skipConfirmation) {
        const gateway = await ario.getGateway({ address: signerAddress });
        if (!gateway) {
            throw new Error(`Gateway not found for address: ${signerAddress}`);
        }
        await (0, utils_js_1.assertConfirmationPrompt)('Gateway Details:\n\n' +
            (0, utils_js_1.stringifyJsonForCLIDisplay)(gateway) +
            '\n\n' +
            'Are you sure you want to leave the AR.IO network?', options);
    }
    return (0, utils_js_1.writeARIOFromOptions)(options).ario.leaveNetwork((0, utils_js_1.writeActionTagsFromOptions)(options));
}
exports.leaveNetwork = leaveNetwork;
async function saveObservations(o) {
    const failedGateways = (0, utils_js_1.requiredStringArrayFromOptions)(o, 'failedGateways');
    const reportTxId = (0, utils_js_1.requiredStringFromOptions)(o, 'transactionId');
    await (0, utils_js_1.assertConfirmationPrompt)(`You are about to save the following failed gateways to the AR.IO network:\n\n${failedGateways.join('\n')}\n\nTransaction ID: ${reportTxId}\n\nAre you sure?`, o);
    return (0, utils_js_1.writeARIOFromOptions)(o).ario.saveObservations({
        failedGateways: (0, utils_js_1.requiredStringArrayFromOptions)(o, 'failedGateways'),
        reportTxId: (0, utils_js_1.requiredStringFromOptions)(o, 'transactionId'),
    }, (0, utils_js_1.writeActionTagsFromOptions)(o));
}
exports.saveObservations = saveObservations;
async function increaseOperatorStake(o) {
    const increaseQty = (0, utils_js_1.requiredMIOFromOptions)(o, 'operatorStake');
    await (0, utils_js_1.assertConfirmationPrompt)(`You are about to increase your operator stake by ${(0, utils_js_1.formatARIOWithCommas)(increaseQty.toARIO())} ARIO\nAre you sure?`, o);
    return ((0, utils_js_1.writeARIOFromOptions)(o).ario.increaseOperatorStake({
        increaseQty,
    }),
        (0, utils_js_1.writeActionTagsFromOptions)(o));
}
exports.increaseOperatorStake = increaseOperatorStake;
async function decreaseOperatorStake(o) {
    const decreaseQty = (0, utils_js_1.requiredMIOFromOptions)(o, 'operatorStake');
    // TODO: Can assert stake is sufficient for action, and new target stake meets contract minimum
    await (0, utils_js_1.assertConfirmationPrompt)(`You are about to decrease your operator stake by ${(0, utils_js_1.formatARIOWithCommas)(decreaseQty.toARIO())} ARIO\nAre you sure?`, o);
    return (0, utils_js_1.writeARIOFromOptions)(o).ario.decreaseOperatorStake({
        decreaseQty,
    }, (0, utils_js_1.writeActionTagsFromOptions)(o));
}
exports.decreaseOperatorStake = decreaseOperatorStake;
async function instantWithdrawal(o) {
    const vaultId = (0, utils_js_1.requiredStringFromOptions)(o, 'vaultId');
    const gatewayAddress = (0, utils_js_1.requiredAddressFromOptions)(o);
    await (0, utils_js_1.assertConfirmationPrompt)(`You are about to instantly withdraw from vault ${vaultId} for with gateway address ${gatewayAddress}\nAre you sure?`, o);
    return (0, utils_js_1.writeARIOFromOptions)(o).ario.instantWithdrawal({
        vaultId,
        gatewayAddress,
    }, (0, utils_js_1.writeActionTagsFromOptions)(o));
}
exports.instantWithdrawal = instantWithdrawal;
async function cancelWithdrawal(o) {
    const vaultId = (0, utils_js_1.requiredStringFromOptions)(o, 'vaultId');
    const gatewayAddress = (0, utils_js_1.requiredAddressFromOptions)(o);
    await (0, utils_js_1.assertConfirmationPrompt)(`You are about to cancel the pending withdrawal from vault ${vaultId} for with gateway address ${gatewayAddress}\nAre you sure?`, o);
    return (0, utils_js_1.writeARIOFromOptions)(o).ario.cancelWithdrawal({
        vaultId,
        gatewayAddress,
    }, (0, utils_js_1.writeActionTagsFromOptions)(o));
}
exports.cancelWithdrawal = cancelWithdrawal;
async function delegateStake(options) {
    const { ario, signerAddress } = (0, utils_js_1.writeARIOFromOptions)(options);
    const { target, arioQuantity } = (0, utils_js_1.requiredTargetAndQuantityFromOptions)(options);
    const mARIOQuantity = arioQuantity.toMARIO();
    if (!options.skipConfirmation) {
        const balance = await ario.getBalance({ address: signerAddress });
        if (balance < mARIOQuantity.valueOf()) {
            throw new Error(`Insufficient ARIO balance for delegating stake. Balance available: ${new index_js_1.mARIOToken(balance).toARIO()} ARIO`);
        }
        const targetGateway = await ario.getGateway({ address: target });
        if (targetGateway === undefined) {
            throw new Error(`Gateway not found for address: ${target}`);
        }
        if (targetGateway.settings.allowDelegatedStaking === false) {
            throw new Error(`Gateway does not allow delegated staking: ${target}`);
        }
        // TODO: could get allow list and assert doesn't exist or user is on it
        // TODO: could read from contract to get current delegated stake if there is none, get contract minimum delegated stake. Then see if the new stake value will satisfy minimum delegated stake for both the target gateway settings min delegate stake and contract min delegated amounts
        const { confirm } = await (0, prompts_1.default)({
            type: 'confirm',
            name: 'confirm',
            message: `Target Gateway:\n${JSON.stringify(targetGateway, null, 2)}\n\nAre you sure you want to delegate ${(0, utils_js_1.formatARIOWithCommas)(arioQuantity)} ARIO to ${target}?`,
        });
        if (!confirm) {
            return { message: 'Delegate stake aborted by user' };
        }
    }
    const result = await ario.delegateStake({
        target,
        stakeQty: arioQuantity.toMARIO(),
    }, (0, utils_js_1.writeActionTagsFromOptions)(options));
    const output = {
        senderAddress: signerAddress,
        transferResult: result,
        message: `Successfully delegated ${(0, utils_js_1.formatARIOWithCommas)(arioQuantity)} ARIO to ${target}`,
    };
    return output;
}
exports.delegateStake = delegateStake;
async function decreaseDelegateStake(options) {
    const ario = (0, utils_js_1.writeARIOFromOptions)(options).ario;
    const { target, arioQuantity } = (0, utils_js_1.requiredTargetAndQuantityFromOptions)(options);
    const instant = options.instant ?? false;
    // TODO: Could assert sender is a delegate with enough stake to decrease
    // TODO: Could assert new target stake meets contract and target gateway minimums
    // TODO: Could present confirmation prompt with any fee for instant withdrawal (50% of the stake is put back into protocol??)
    await (0, utils_js_1.assertConfirmationPrompt)(`Are you sure you'd like to decrease delegated stake of ${(0, utils_js_1.formatARIOWithCommas)(arioQuantity)} ARIO on gateway ${target}?`, options);
    const result = await ario.decreaseDelegateStake({
        target,
        decreaseQty: arioQuantity.toMARIO(),
        instant,
    });
    const output = {
        targetGateway: target,
        decreaseDelegateStakeResult: result,
        message: `Successfully decreased delegated stake of ${(0, utils_js_1.formatARIOWithCommas)(arioQuantity)} ARIO to ${target}`,
    };
    return output;
}
exports.decreaseDelegateStake = decreaseDelegateStake;
async function redelegateStake(options) {
    const ario = (0, utils_js_1.writeARIOFromOptions)(options).ario;
    const params = (0, utils_js_1.redelegateParamsFromOptions)(options);
    // TODO: Could assert target gateway exists
    // TODO: Could do assertion on source has enough stake to redelegate
    // TODO: Could do assertions on source/target min delegate stakes are met
    await (0, utils_js_1.assertConfirmationPrompt)(`Are you sure you'd like to redelegate stake of ${(0, utils_js_1.formatARIOWithCommas)(params.stakeQty.toARIO())} ARIO from ${params.source} to ${params.target}?`, options);
    const result = await ario.redelegateStake(params);
    const output = {
        sourceGateway: params.source,
        targetGateway: params.target,
        redelegateStakeResult: result,
        message: `Successfully re-delegated stake of ${(0, utils_js_1.formatARIOWithCommas)(params.stakeQty.toARIO())} ARIO from ${params.source} to ${params.target}`,
    };
    return output;
}
exports.redelegateStake = redelegateStake;
