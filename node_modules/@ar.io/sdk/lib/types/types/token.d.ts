/// <reference types="node" />
interface Equatable<T> {
    equals(other: T): boolean;
}
declare class PositiveFiniteInteger implements Equatable<PositiveFiniteInteger> {
    private readonly positiveFiniteInteger;
    constructor(positiveFiniteInteger: number);
    [Symbol.toPrimitive](hint?: string): number | string;
    plus(positiveFiniteInteger: PositiveFiniteInteger): PositiveFiniteInteger;
    minus(positiveFiniteInteger: PositiveFiniteInteger): PositiveFiniteInteger;
    isGreaterThan(positiveFiniteInteger: PositiveFiniteInteger): boolean;
    isGreaterThanOrEqualTo(positiveFiniteInteger: PositiveFiniteInteger): boolean;
    isLessThan(positiveFiniteInteger: PositiveFiniteInteger): boolean;
    isLessThanOrEqualTo(positiveFiniteInteger: PositiveFiniteInteger): boolean;
    toString(): string;
    valueOf(): number;
    toJSON(): number;
    equals(other: PositiveFiniteInteger): boolean;
}
export declare class ARIOToken {
    protected value: number;
    constructor(value: number);
    valueOf(): number;
    toMARIO(): mARIOToken;
    toString(): string;
}
export declare class mARIOToken extends PositiveFiniteInteger {
    constructor(value: number);
    multiply(multiplier: mARIOToken | number): mARIOToken;
    divide(divisor: mARIOToken | number): mARIOToken;
    plus(addend: mARIOToken): mARIOToken;
    minus(subtractHend: mARIOToken): mARIOToken;
    toARIO(): ARIOToken;
}
export type AoSigner = (args: {
    data: string | Buffer;
    tags?: {
        name: string;
        value: string;
    }[];
    target?: string;
    anchor?: string;
}) => Promise<{
    id: string;
    raw: ArrayBuffer;
}>;
export {};
